# % 取模(取余)
 %的本质 看一个公式 a % b = a - a / b * b
 -10 % 3 => -10 - (-10) / 3 * 3 = -1
 10 % -3 => 10 - 10 / (-3) * (-3) = 1
 -10 % -3 => (-10) - (-10) / (-3) * (-3) = -1

# 自增:++
*作为独立的语句使用: 前++ 和 后++ 都完全等价于 i=i+1;
*作为表达式使用: ++i: 先自增后赋值  i++: 先赋值后自增;

# 逻辑运算符
(1) 短路与&&, 短路或||, 取反!
(2) 逻辑与&, 逻辑或|, 逻辑异或^
    a^b: 逻辑异或,当a和b不同时,结果为true,否则为false

*使用区别:
 1.短路与(或):如果第一个条件为false(true),则第二个条件不会判断,最终结果为false(true),效率高
 2.逻辑与(或):不管第一个条件是否为false(true),第二个条件都要判断,效率低
 3.开发中,我们使用的基本都是短路与(或),效率高

# 赋值运算符
(1)基本赋值运算符 =  (2)复合赋值运算符 +=, -=, *=, /=, %= ;  a += b[等价 a = a + b ]

*使用细节:复合赋值运算符会进行类型转换
 byte b = 3;
 b += 2; // 等价 b = (byte)(b + 2);
 b = b + 2; // 错误
 b +; // 等价 b = (byte)(b + 1);

 # 标识符的命名规则和规范
 1.包名:多单词组成时,所有字母都小写: aaa.bbb.ccc // 比如com.hsp.crm
 2.类名、接口名:多单词组成时,所有单词的首字母大写,例如:TankShotGame
 3.变量名、方法名:多单词组成时,第一个单词首字母小写,第二个单词开始每个单词首字母大写,例如:tankShotGame
 4.常量名:所有字母大写,多单词时,用下划线连接,例如:TAX_RATE

 # 进制介绍
 对于整数,有四种表示方式:
  1.二进制: 0,1 , 满2进1. 以0b或0B开头.
  2.十进制: 0-9 , 满10进1.
  3.八进制: 0-7 , 满8进1. 以数字0开头表示.
  4.十六进制: 0-9及A(10)-F(15), 满16进1. 以0x或0X开头表示. 此处的A-F不区分大小写.

 # 进制转换的介绍
 *第一组:
  1.二进制转十进制
   规则: 从最低位(右边)开始,将每个位上的数提取出来,乘以2的(位数-1)次方,然后求和
   案例: 请将0b1011转成十进制的数
        0b1011 = 1*2^0 + 1*2^1 + 0*2^2 + 1*2^3 = 1+2+0+8 = 11

  2.八进制转十进制
   规则: 从最低位(右边)开始,将每个位上的数提取出来,乘以8的(位数-1)次方,然后求和
   案例: 请将0234转成十进制的数
        0234 = 4*8^0 + 3*8^1 + 2*8^2 = 4+24+128 = 156

  3.十六进制转十进制
   规则: 从最低位(右边)开始,将每个位上的数提取出来,乘以16的(位数-1)次方,然后求和
   案例: 请将0x23A转成十进制的数
        0x23A = 10*16^0 + 3*16^1 + 2*16^2 = 10+48+512 = 570

 *第二组:
  1.十进制转二进制
   规则: 将该数不断除以2,直到商为0为止,然后将每步得到的余数倒过来,就是对应的二进制
   案例: 请将34转成二进制  0B00100010  [0B后面要补两个0,原因是2个字节是8位,计算得出的100010只有6位]
   
  2.十进制转八进制
   规则: 将该数不断除以8,直到商为0为止,然后将每步得到的余数倒过来,就是对应的八进制
   案例: 请将131转成二进制  0203

  3.十进制转十六进制
   规则: 将该数不断除以16,直到商为0为止,然后将每步得到的余数倒过来,就是对应的十六进制
   案例: 请将237转成二进制  0xED

 *第三组:
  1.二进制转八进制
   规则: 从低位开始,将二进制数每三位一组,转成对应的八进制数即可[为什么是每三位? 原因是111表示7,000表示0, 0-7表示完整的八进制]
   ⭐️ 八进制中的111分别代表4,2,1.   111= 4+2+1 = 7
   案例: 请将0b11010101转成八进制   0b 11(3) 010(2) 101(5) => 0325

  2.二进制转十六进制
   规则: 从低位开始,将二进制数每四位一组,转成对应的十六进制数即可[为什么是每四位? 原因是1111表示F,0000表示0, 0-F表示完整的十六进制]
   ⭐️ 十六进制中的1111分别代表8,4,2,1.  
   案例: 请将0b11010101转成十六进制  0b 1101(13)0101(5) => 0xD5

 *第四组:
  1.八进制转二进制
   规则: 将八进制的每1位,转成对应的一个[3位]的二进制数即可
   案例: 请将0237转成二进制  0 2(010)3(011)7(111) => 0b10011111

  2.十六进制转二进制
   规则: 将十六进制的每1位,转成对应的一个[4位]的二进制数即可
   案例: 请将0x23B转成二进制 0x 2(0010)3(0011)B(1011) => 0b001000111011

# 原码、反码、补码
 1.二进制的最高位是符号位:0表示正数,1表示负数(口诀:0-> 0 1-> -)
 2.⭐️正数的原码,反码,补码都一样(三码合一)
 3.⭐️负数的反码 = 它的原码符号位不变,其他位取反(0 -> 1,1 -> 0)
 4.⭐️负数的补码 = 它的反码 + 1, 负数的反码 = 它的补码 - 1
 5.0的反码,补码都是0
 6.java没有无符号数,换言之,java中的数都是有符号的
 7.⭐️在计算机运算的时候,都是以[补码的方式]来运算的
 8.⭐️当我们看运算结果时,要看它的原码 [重点]

 例: 
 (1) 2&3 = ?
     2,3是int类型,占4个字节
     2的原码: 00000000 00000000 00000000 00000010
     2的补码: 00000000 00000000 00000000 00000010
     3的补码: 00000000 00000000 00000000 00000011
       2&3 : 00000000 00000000 00000000 00000010 [补码方式]
    转成原码: 00000000 00000000 00000000 00000010  => 2  => 2&3 = 2
 (2) ~-2 = ?
     -2的原码: 10000000 00000000 00000000 00000010
     -2的反码: 11111111 11111111 11111111 11111101
     -2的补码: 11111111 11111111 11111111 11111110
         ~-2: 00000000 00000000 00000000 00000001 [补码方式]
     转成原码: 00000000 00000000 00000000 00000001 => 1 => ~-2 = 1
 (3) ~2 = ?
      2的原码: 00000000 00000000 00000000 00000010
      2的补码: 00000000 00000000 00000000 00000010
          ~2: 11111111 11111111 11111111 11111101 [补码方式]
     转成原码: 反码方式(补码-1):11111111 11111111 11111111 11111100 ; 原码方式:100000000 00000000 00000000 00000011 => -3 => ~2 = -3
 (4) 2|3 = ?
     2的补码: 00000000 00000000 00000000 00000010
     3的补码: 00000000 00000000 00000000 00000011
       2|3 : 00000000 00000000 00000000 00000011 [补码方式]
    转成原码: 00000000 00000000 00000000 00000011 => 3  => 2|3 = 3
 (4) 2^3 = ?
     2的补码: 00000000 00000000 00000000 00000010
     3的补码: 00000000 00000000 00000000 00000011
       2^3 : 00000000 00000000 00000000 00000001 [补码方式]
    转成原码: 00000000 00000000 00000000 00000001 => 1  => 2^3 = 1

# 位运算
*java中有7个位运算(按位与&、按位或|、按位异或^、按位取反~、算术右移>>、算术左移<< 和 无符号右移 >>>)
按位与&: 两位全为1,结果为1,否则为0
按位或|: 两位有一个为1,结果为1,否则为0
按位异或^: 两位一个为0一个为1,结果为1,否则为0
按位取反~: 0->1 1->0
算术右移>>: 低位溢出,符号位不变,并用符号位补溢出的高位
算术左移<<: 符号位不变,低位补0
无符号右移>>>: 低位溢出,高位补0

例: int a = 1>>2;  1 => 00000001 => 00000000  本质1/2/2 = 0
    int c = 1<<2;  1 => 00000001 => 00000100  本质1*2*2 = 4
    int b = -1<<2; 
    -1 => 原码 10000000 00000000 00000000 0000001 
          反码 11111111 11111111 11111111 11111110
          补码 11111111 11111111 11111111 11111111
        -1<<2 11111111 11111111 11111111 11111100 [补码形式]
      转成反码 11111111 11111111 11111111 11111011
      转成原码 10000000 00000000 00000000 00000100 => -4

    int d = -1>>2; 
    -1 => 原码 10000000 00000000 00000000 0000001 
          反码 11111111 11111111 11111111 11111110
          补码 11111111 11111111 11111111 11111111
        -1>>2 11111111 11111111 11111111 11111111 [补码形式]
       转成反码 11111111 11111111 11111111 11111110
       转成原码 10000000 00000000 00000000 00000001 => -1

 




